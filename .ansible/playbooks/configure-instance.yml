---
###############################################################################
# Ansible Playbook: Configure EC2 Instance for AMI Creation
###############################################################################
# Purpose: This playbook is used by Packer to configure a new EC2 instance
#          that will become our "Golden Image" (AMI)
#
# When is this used?
# - During the GitHub Actions workflow
# - Packer launches a temporary EC2 instance
# - Packer runs this playbook on that instance
# - Instance is configured with the latest JAR
# - Packer creates an AMI snapshot
# - Temporary instance is terminated
###############################################################################

- name: Configure EC2 Instance for Schedemy Application
  hosts: all
  become: yes
  gather_facts: yes
  
  vars:
    # Application configuration
    app_name: schedemy
    app_dir: /opt/schedemy
    app_user: deploy
    app_group: deploy
    jar_filename: EduSched-0.0.1-SNAPSHOT.jar
    
    # Java configuration
    java_version: "17"
    
    # Service configuration
    service_port: 8080
    jvm_opts: "-Xms512m -Xmx1024m -XX:+UseG1GC"
  
  ###############################################################################
  # STEP 1: System Updates & Prerequisites
  ###############################################################################
  tasks:
    - name: Update all packages (security patches)
      yum:
        name: '*'
        state: latest
        update_cache: yes
      register: yum_update
      retries: 3
      delay: 10
    
    - name: Install required system packages
      yum:
        name:
          - java-{{ java_version }}-amazon-corretto-devel  # Java 17
          - aws-cli                                         # For S3 access
          - wget                                            # Download utilities
          - curl                                            # HTTP client
          - vim                                             # Text editor
          - htop                                            # Process viewer
          - net-tools                                       # Network tools
        state: present
      retries: 3
      delay: 10
    
    - name: Verify Java installation
      command: java -version
      register: java_version_check
      changed_when: false
    
    - name: Display Java version
      debug:
        msg: "{{ java_version_check.stderr_lines }}"
    
    ###########################################################################
    # STEP 2: Create Application User & Directory
    ###########################################################################
    - name: Create application group
      group:
        name: "{{ app_group }}"
        state: present
        system: yes
    
    - name: Create application user
      user:
        name: "{{ app_user }}"
        group: "{{ app_group }}"
        home: "{{ app_dir }}"
        shell: /bin/bash
        create_home: no
        system: yes
        comment: "Schedemy Application User"
    
    - name: Create application directory
      file:
        path: "{{ app_dir }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: '0755'
    
    - name: Create logs directory
      file:
        path: "{{ app_dir }}/logs"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: '0755'
    
    - name: Create backups directory
      file:
        path: "{{ app_dir }}/backups"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: '0755'
    
    ###########################################################################
    # STEP 3: Copy Application JAR
    ###########################################################################
    # NOTE: The JAR is copied from Packer's provisioning directory
    # Packer uploads it before running this playbook
    
    - name: Copy application JAR to application directory
      copy:
        src: "/tmp/{{ jar_filename }}"
        dest: "{{ app_dir }}/{{ jar_filename }}"
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: '0644'
        remote_src: yes
      register: jar_copy
    
    - name: Verify JAR was copied
      stat:
        path: "{{ app_dir }}/{{ jar_filename }}"
      register: jar_stat
      failed_when: not jar_stat.stat.exists or jar_stat.stat.size == 0
    
    - name: Display JAR information
      debug:
        msg:
          - "JAR copied successfully"
          - "Size: {{ (jar_stat.stat.size / 1024 / 1024) | round(2) }} MB"
          - "Owner: {{ jar_stat.stat.pw_name }}"
    
    ###########################################################################
    # STEP 4: Create Systemd Service
    ###########################################################################
    - name: Create systemd service file
      template:
        dest: /etc/systemd/system/{{ app_name }}.service
        owner: root
        group: root
        mode: '0644'
        content: |
          [Unit]
          Description=Schedemy Spring Boot Application
          After=network.target
          
          [Service]
          Type=simple
          User={{ app_user }}
          Group={{ app_group }}
          WorkingDirectory={{ app_dir }}
          
          # Java execution
          ExecStart=/usr/bin/java {{ jvm_opts }} -jar {{ app_dir }}/{{ jar_filename }}
          
          # Restart policy
          Restart=on-failure
          RestartSec=10
          
          # Standard output and error logging
          StandardOutput=append:{{ app_dir }}/logs/application.log
          StandardError=append:{{ app_dir }}/logs/error.log
          
          # Security hardening
          PrivateTmp=true
          NoNewPrivileges=true
          
          # Resource limits
          LimitNOFILE=65535
          
          [Install]
          WantedBy=multi-user.target
      register: service_file
    
    - name: Reload systemd daemon
      systemd:
        daemon_reload: yes
      when: service_file.changed
    
    - name: Enable service to start on boot
      systemd:
        name: "{{ app_name }}"
        enabled: yes
    
    ###########################################################################
    # STEP 5: Configure Log Rotation
    ###########################################################################
    - name: Create logrotate configuration
      copy:
        dest: /etc/logrotate.d/{{ app_name }}
        owner: root
        group: root
        mode: '0644'
        content: |
          {{ app_dir }}/logs/*.log {
              daily
              rotate 14
              compress
              delaycompress
              notifempty
              missingok
              create 0644 {{ app_user }} {{ app_group }}
              sharedscripts
              postrotate
                  systemctl reload {{ app_name }} > /dev/null 2>&1 || true
              endscript
          }
    
    ###########################################################################
    # STEP 6: Configure CloudWatch Agent (Optional)
    ###########################################################################
    - name: Check if CloudWatch agent should be installed
      set_fact:
        install_cloudwatch: false  # Set to true if you want CloudWatch logs
    
    - name: Install CloudWatch agent
      shell: |
        wget https://s3.amazonaws.com/amazoncloudwatch-agent/amazon_linux/amd64/latest/amazon-cloudwatch-agent.rpm
        rpm -U ./amazon-cloudwatch-agent.rpm
        rm -f ./amazon-cloudwatch-agent.rpm
      args:
        creates: /opt/aws/amazon-cloudwatch-agent/bin/amazon-cloudwatch-agent-ctl
      when: install_cloudwatch | bool
    
    ###########################################################################
    # STEP 7: Security Hardening
    ###########################################################################
    - name: Configure firewall (if firewalld is present)
      block:
        - name: Check if firewalld is installed
          command: which firewalld
          register: firewalld_check
          failed_when: false
          changed_when: false
        
        - name: Allow application port through firewall
          firewalld:
            port: "{{ service_port }}/tcp"
            permanent: yes
            state: enabled
            immediate: yes
          when: firewalld_check.rc == 0
      when: false  # Disabled by default for AWS (security groups handle this)
    
   
      
    
    ###########################################################################
    # STEP 8: System Optimization
    ###########################################################################
    - name: Increase file descriptor limits
      pam_limits:
        domain: "{{ app_user }}"
        limit_type: "{{ item.limit_type }}"
        limit_item: nofile
        value: "{{ item.value }}"
      loop:
        - { limit_type: 'soft', value: '65535' }
        - { limit_type: 'hard', value: '65535' }
    
    - name: Configure sysctl for better network performance
      sysctl:
        name: "{{ item.name }}"
        value: "{{ item.value }}"
        state: present
        reload: yes
      loop:
        - { name: 'net.core.somaxconn', value: '1024' }
        - { name: 'net.ipv4.tcp_max_syn_backlog', value: '2048' }
      failed_when: false
    
    ###########################################################################
    # STEP 9: Cleanup & Final Checks
    ###########################################################################
    - name: Clean yum cache
      command: yum clean all
      changed_when: false
    
    - name: Remove temporary files
      file:
        path: "/tmp/{{ jar_filename }}"
        state: absent
    
    - name: Verify service can start (test run)
      systemd:
        name: "{{ app_name }}"
        state: started
      register: service_start
    
    - name: Wait for application to initialize
      pause:
        seconds: 15
    
    - name: Check if application is responding
      uri:
        url: "http://localhost:{{ service_port }}/actuator/health"
        method: GET
        timeout: 5
      register: health_check
      failed_when: false
      changed_when: false
      when: false  # Disabled - enable if you have actuator endpoint
    
    - name: Stop service (AMI should not have running services)
      systemd:
        name: "{{ app_name }}"
        state: stopped
    
    - name: Display configuration summary
      debug:
        msg:
          - "========================================="
          - "Instance configuration completed!"
          - "Application: {{ app_name }}"
          - "User: {{ app_user }}"
          - "Directory: {{ app_dir }}"
          - "Service: {{ app_name }}.service"
          - "JAR: {{ jar_filename }}"
          - "Port: {{ service_port }}"
          - "========================================="
          - "This instance is ready to be converted to an AMI"

###############################################################################
# IMPORTANT NOTES FOR AMI CREATION:
#
# 1. Service should be ENABLED but not RUNNING
#    - enabled: yes → starts automatically when instance launches
#    - state: stopped → not running in the AMI snapshot
#
# 2. No instance-specific data should be in the AMI
#    - No SSH keys (these are injected by EC2)
#    - No instance-specific configuration
#    - No logs from this configuration run
#
# 3. The AMI should be as generic as possible
#    - Works in any AZ
#    - Works with any instance type (within reason)
#    - Contains only the application, not runtime state
###############################################################################
