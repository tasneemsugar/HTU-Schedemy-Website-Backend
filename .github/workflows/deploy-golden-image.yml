name: Deploy with Golden Image

# When to run this workflow
on:
  push:
    branches: 
      - main  # Runs when code is pushed to main branch
  workflow_dispatch:  # Allows manual triggering from GitHub UI
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging

# Environment variables available to all jobs
env:
  AWS_REGION: us-east-1
  APP_NAME: schedemy
  JAVA_VERSION: 17

jobs:
  ###############################################################################
  # JOB 1: Build Application
  ###############################################################################
  build:
    name: Build Spring Boot Application
    runs-on: ubuntu-latest
    
    # Output variables that other jobs can use
    outputs:
      version: ${{ steps.version.outputs.version }}
      artifact_path: ${{ steps.build.outputs.artifact_path }}
    
    steps:
      # STEP 1: Checkout code from repository
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # STEP 2: Set up Java
      - name: Set Up Java ${{ env.JAVA_VERSION }}
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'  # Cache Maven dependencies for faster builds
      
      # STEP 3: Extract version from pom.xml
      - name:  Extract Version
        id: version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Application version: ${VERSION}"
      
      # STEP 4: Build the application
      - name: Build with Maven
        id: build
        run: |
          mvn clean package -DskipTests
          echo "artifact_path=target/EduSched-0.0.1-SNAPSHOT.jar" >> $GITHUB_OUTPUT
          ls -lh target/*.jar
      
      # STEP 5: Upload JAR as artifact (for next job)
      - name: Upload JAR Artifact
        uses: actions/upload-artifact@v4
        with:
          name: application-jar
          path: target/*.jar
          retention-days: 5

  ###############################################################################
  # JOB 2: Create Golden Image (AMI)
  ###############################################################################
  create-ami:
    name: Create Golden Image AMI
    runs-on: ubuntu-latest
    needs: build  # This job waits for 'build' job to complete
    
    # Output the AMI ID for the next job
    outputs:
      ami_id: ${{ steps.ami.outputs.ami_id }}
      ami_name: ${{ steps.ami.outputs.ami_name }}
    
    steps:
      # STEP 1: Checkout code (we need the Packer and Ansible files)
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # STEP 2: Download the JAR we built in the previous job
      - name: Download JAR Artifact
        uses: actions/download-artifact@v4
        with:
          name: application-jar
          path: ./target
      
      # STEP 3: Set up Packer
      - name:  Setup Packer
        uses: hashicorp/setup-packer@main
        with:
          version: 'latest'
      
      # STEP 4: Configure AWS credentials
      - name:  Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # STEP 5: Install Ansible (required by Packer)
      - name: Setup Python & Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install ansible boto3 botocore
          ansible --version
      
      # STEP 6: Validate Packer template
      - name: Validate Packer Template
        run: |
          cd packer
          packer init .
          packer validate \
            -var "app_version=${{ needs.build.outputs.version }}" \
            -var "jar_file_path=../target/EduSched-0.0.1-SNAPSHOT.jar" \
            schedemy-ami.pkr.hcl
      
      # STEP 7: Build AMI with Packer
      - name: Build AMI with Packer
        id: packer_build
        run: |
          cd packer
          packer build \
            -var "app_version=${{ needs.build.outputs.version }}" \
            -var "jar_file_path=../target/EduSched-0.0.1-SNAPSHOT.jar" \
            -var "aws_region=${{ env.AWS_REGION }}" \
            schedemy-ami.pkr.hcl
        timeout-minutes: 30  # Fail if build takes too long
      
      # STEP 8: Extract AMI ID from Packer manifest
      - name: Extract AMI Information
        id: ami
        run: |
          AMI_ID=$(jq -r '.builds[-1].artifact_id' packer/packer-manifest.json | cut -d':' -f2)
          AMI_NAME=$(jq -r '.builds[-1].custom_data.ami_name' packer/packer-manifest.json 2>/dev/null || echo "schedemy-${{ needs.build.outputs.version }}")
          
          echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT
          echo "ami_name=${AMI_NAME}" >> $GITHUB_OUTPUT
          
          echo "AMI Created Successfully!"
          echo "AMI ID: ${AMI_ID}"
          echo "AMI Name: ${AMI_NAME}"
      
      # STEP 9: Upload Packer manifest as artifact
      - name: Upload Packer Manifest
        uses: actions/upload-artifact@v4
        with:
          name: packer-manifest
          path: packer/packer-manifest.json
          retention-days: 30

  ###############################################################################
  # JOB 3: Update Launch Template & Deploy
  ###############################################################################
  deploy:
    name: Update Launch Template & Deploy
    runs-on: ubuntu-latest
    needs: [build, create-ami]  # Waits for both previous jobs
    
    steps:
      # STEP 1: Checkout code
      - name: Checkout Code
        uses: actions/checkout@v4
      
      # STEP 2: Configure AWS credentials
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      # STEP 3: Create new Launch Template version with new AMI
      - name: Create New Launch Template Version
        id: launch_template
        run: |
          # Get the current launch template ID
          LT_ID=$(aws ec2 describe-launch-templates \
            --filters "Name=tag:Name,Values=schedemy01-template" \
            --query 'LaunchTemplates[0].LaunchTemplateId' \
            --output text)
          
          echo "Launch Template ID: ${LT_ID}"
          
          # Create new version with new AMI
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-id ${LT_ID} \
            --source-version '$Latest' \
            --launch-template-data "{\"ImageId\":\"${{ needs.create-ami.outputs.ami_id }}\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "Created Launch Template Version: ${NEW_VERSION}"
          echo "lt_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          
          # Set the new version as default
          aws ec2 modify-launch-template \
            --launch-template-id ${LT_ID} \
            --default-version ${NEW_VERSION}
          
          echo " Set version ${NEW_VERSION} as default"
      
      # STEP 4: Trigger Auto Scaling Group Instance Refresh
      - name:  Trigger Instance Refresh
        id: instance_refresh
        run: |
          ASG_NAME="schedemy01-ASG"
          
          echo " Starting instance refresh for ${ASG_NAME}..."
          
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name ${ASG_NAME} \
            --preferences '{
              "MinHealthyPercentage": 90,
              "InstanceWarmup": 120,
              "CheckpointPercentages": [50, 100],
              "CheckpointDelay": 300,
              "SkipMatching": false
            }' \
            --query 'InstanceRefreshId' \
            --output text)
          
          echo " Instance Refresh Started"
          echo " Refresh ID: ${REFRESH_ID}"
          echo "refresh_id=${REFRESH_ID}" >> $GITHUB_OUTPUT
      
      # STEP 5: Monitor Instance Refresh (optional - can be slow)
      - name:  Monitor Instance Refresh
        if: false  # Set to true if you want to wait for completion
        run: |
          ASG_NAME="schedemy01-ASG"
          REFRESH_ID="${{ steps.instance_refresh.outputs.refresh_id }}"
          
          echo "Monitoring instance refresh: ${REFRESH_ID}"
          
          while true; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${ASG_NAME} \
              --instance-refresh-ids ${REFRESH_ID} \
              --query 'InstanceRefreshes[0].Status' \
              --output text)
            
            PERCENTAGE=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${ASG_NAME} \
              --instance-refresh-ids ${REFRESH_ID} \
              --query 'InstanceRefreshes[0].PercentageComplete' \
              --output text)
            
            echo "Status: ${STATUS} | Progress: ${PERCENTAGE}%"
            
            if [[ "${STATUS}" == "Successful" ]]; then
              echo " Instance refresh completed successfully!"
              break
            elif [[ "${STATUS}" == "Failed" ]] || [[ "${STATUS}" == "Cancelled" ]]; then
              echo " Instance refresh ${STATUS}"
              exit 1
            fi
            
            sleep 30
          done
        timeout-minutes: 30
      
      # STEP 6: Send notification (optional)
      - name:  Send Deployment Notification
        if: always()  # Run even if previous steps failed
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            STATUS=" SUCCESS"
            MESSAGE="Deployment completed successfully!"
          else
            STATUS="FAILED"
            MESSAGE="Deployment failed. Please check the logs."
          fi
          
          # You can send to SNS, Slack, email, etc.
          # Example with SNS (uncomment if you have SNS_TOPIC_ARN secret):
          # aws sns publish \
          #   --topic-arn ${{ secrets.SNS_TOPIC_ARN }} \
          #   --subject "Schedemy Deployment ${STATUS}" \
          #   --message "
          #     Application: Schedemy
          #     Version: ${{ needs.build.outputs.version }}
          #     AMI: ${{ needs.create-ami.outputs.ami_id }}
          #     Status: ${MESSAGE}
          #     Time: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
          #   "
          
          echo "${STATUS}: ${MESSAGE}"
      
      # STEP 7: Display deployment summary
      - name:  Deployment Summary
        run: |
          echo "========================================="
          echo " DEPLOYMENT COMPLETED SUCCESSFULLY"
          echo "========================================="
          echo "Application: Schedemy"
          echo "Version: ${{ needs.build.outputs.version }}"
          echo "AMI ID: ${{ needs.create-ami.outputs.ami_id }}"
          echo "AMI Name: ${{ needs.create-ami.outputs.ami_name }}"
          echo "Launch Template Version: ${{ steps.launch_template.outputs.lt_version }}"
          echo " Instance Refresh ID: ${{ steps.instance_refresh.outputs.refresh_id }}"
          echo "Deployed at: $(date -u +'%Y-%m-%d %H:%M:%S UTC')"
          echo "========================================="
          echo ""
          echo "Next Steps:"
          echo "1. Monitor instance refresh in AWS Console"
          echo "2. Check application health at https://schedemyapi.htufolio.com"
          echo "3. Verify new instances are serving traffic"
          echo ""
          echo "To rollback:"
          echo "   Set Launch Template to previous version and trigger new refresh"
          echo "========================================="
